// parte2m.c - ATmega328P MAESTRO I2C
// DHT11 en PD2, Pulsador en PD3, Potenci�metro en A0, LCD I2C 16x2.
// Env�a 3 bytes por I2C a un esclavo ATmega:
// 1) valor de pot escalado 0..255,
// 2) flag_temp_mayor (0/1),
// 3) flag_boton (0/1).

#ifndef F_CPU
#define F_CPU 16000000UL
#endif

#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdio.h>

#include "adc.h"    // ADC_INICIAR, ADC_LEER_CANAL
#include "i2c.h"    // I2C_INICIAR, I2C_INICIAR_CONDICION, I2C_ENVIAR_BYTE, I2C_DETENER_CONDICION
#include "lcd.h"    // LCD_INICIAR, LCD_MOSTRAR

//---------------- Direcci�n I2C del esclavo ATmega ----------------
#define ESCLAVO_I2C_DIR  0x20   // 7 bits (ejemplo), distinta de la del LCD

//---------------- DHT11 en PD2 ----------------
#define DHT11_DDR   DDRD
#define DHT11_PORT  PORTD
#define DHT11_PINR  PIND
#define DHT11_BIT   PD2

//---------------- Pulsador en PD3 ----------------
#define BTN_DDR     DDRD
#define BTN_PORT    PORTD
#define BTN_PINR    PIND
#define BTN_BIT     PD3

//---------------- Funciones DHT11 ----------------
static void DHT11_PinOutput(void)
{
	DHT11_DDR |= (1 << DHT11_BIT);
}

static void DHT11_PinInput(void)
{
	DHT11_DDR &= ~(1 << DHT11_BIT);
}

static uint8_t DHT11_ReadPin(void)
{
	return (DHT11_PINR & (1 << DHT11_BIT)) ? 1 : 0;
}

static uint8_t DHT11_ReadByte(void)
{
	uint8_t i, byte = 0;

	for (i = 0; i < 8; i++)
	{
		// Esperar flanco a HIGH (fin de pulso bajo ~50us)
		while (DHT11_ReadPin() == 0);
		_delay_us(30);

		byte <<= 1;
		if (DHT11_ReadPin())
		{
			byte |= 1;
		}

		// Esperar que vuelva a LOW
		while (DHT11_ReadPin() == 1);
	}

	return byte;
}

static void DHT11_Leer(uint8_t *temperatura)
{
	uint8_t datos[5] = {0, 0, 0, 0, 0};
	uint8_t i;

	// Se�al de inicio al DHT11
	DHT11_PinOutput();
	DHT11_PORT |= (1 << DHT11_BIT);
	_delay_ms(1);

	DHT11_PORT &= ~(1 << DHT11_BIT);
	_delay_ms(20);

	DHT11_PORT |= (1 << DHT11_BIT);
	_delay_us(30);
	DHT11_PinInput();

	// Respuesta del DHT11: 80us LOW + 80us HIGH
	while (DHT11_ReadPin() == 1);
	while (DHT11_ReadPin() == 0);
	while (DHT11_ReadPin() == 1);

	// Leer 5 bytes
	for (i = 0; i < 5; i++)
	{
		datos[i] = DHT11_ReadByte();
	}

	// Temperatura entera en �C
	*temperatura = datos[2];
}

//---------------- PROGRAMA PRINCIPAL ----------------
int main(void)
{
	uint8_t  temperatura     = 0;
	uint8_t  estado_boton    = 0;
	uint16_t valor_pot       = 0;   // 0..1023
	uint8_t  duty_pwm        = 0;   // 0..255
	uint8_t  flag_temp_mayor = 0;   // 0 o 1
	uint8_t  flag_boton      = 0;   // 0 o 1

	char linea1[17];
	char linea2[17];

	//---- Pulsador PD3 como entrada con pull-up ----
	BTN_DDR  &= ~(1 << BTN_BIT);
	BTN_PORT |= (1 << BTN_BIT);

	//---- Potenci�metro en A0 (PC0) ----
	DDRC &= ~(1 << PC0);   // entrada anal�gica
	ADC_INICIAR();

	//---- I2C (LCD + esclavo ATmega) ----
	I2C_INICIAR();
	LCD_INICIAR();

	while (1)
	{
		//--- Leer temperatura del DHT11 ---
		DHT11_Leer(&temperatura);

		//--- Flag seg�n temperatura ---
		flag_temp_mayor = (temperatura > 27) ? 1 : 0;

		//--- Leer estado del bot�n ---
		// 1 = suelto (pull-up), 0 = presionado (a GND)
		estado_boton = (BTN_PINR & (1 << BTN_BIT)) ? 1 : 0;
		// Flag que se env�a al esclavo: 1 cuando bot�n est� presionado
		flag_boton   = (estado_boton == 0) ? 1 : 0;

		//--- Leer potenci�metro en A0 y escalar a 0..255 ---
		valor_pot = ADC_LEER_CANAL(0);          // 0..1023
		duty_pwm  = (uint8_t)(valor_pot >> 2);  // dividir entre 4 ? 0..255

		//--- Env�o I2C al esclavo: 3 bytes ---
		// 1) duty_pwm (0..255)
		// 2) flag_temp_mayor (0/1)
		// 3) flag_boton (0/1)
		I2C_INICIAR_CONDICION();                              // START
		I2C_ENVIAR_BYTE((ESCLAVO_I2C_DIR << 1) | 0);          // Direcci�n + escritura

		I2C_ENVIAR_BYTE(duty_pwm);
		I2C_ENVIAR_BYTE(flag_temp_mayor);
		I2C_ENVIAR_BYTE(flag_boton);

		I2C_DETENER_CONDICION();                              // STOP

		//--- Actualizar LCD ---
		// L�nea 1: temperatura y valor de potenci�metro crudo
		snprintf(linea1, sizeof(linea1), "T:%3dC  P:%4u", temperatura, valor_pot);

		// L�nea 2: estado del bot�n
		if (estado_boton == 0)
		{
			snprintf(linea2, sizeof(linea2), "BTN:ON");
		}
		else
		{
			snprintf(linea2, sizeof(linea2), "BTN:OFF");
		}

		LCD_MOSTRAR(linea1, linea2);

		_delay_ms(1000);   // 1 actualizaci�n por segundo
	}

	return 0;
}

