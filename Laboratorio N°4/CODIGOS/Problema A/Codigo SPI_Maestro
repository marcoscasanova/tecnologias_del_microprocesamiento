// maestro.c - ATmega328P MAESTRO SPI
// DHT11 en PD2, Pulsador en PD3, Potenci�metro en A0, LCD I2C 16x2.
// Env�a 3 bytes por SPI al esclavo, por cada SS LOW:
// 1) duty_pwm (0..255) desde el potenci�metro,
// 2) flag_temp_mayor (0/1) -> LED temperatura en esclavo,
// 3) flag_boton (0/1)      -> buzzer bot�n en esclavo.

#ifndef F_CPU
#define F_CPU 16000000UL
#endif

#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdio.h>

#include "spi.h"    // SPI_INICIAR, SPI_TRANSFERIR
#include "adc.h"    // ADC_INICIAR, ADC_LEER_CANAL
#include "i2c.h"    // I2C_INICIAR
#include "lcd.h"    // LCD_INICIAR, LCD_MOSTRAR

#define TEMP_UMBRAL 27  // cambi� este valor si quer�s otro umbral

//---------------- DHT11 en PD2 ----------------
#define DHT11_DDR   DDRD
#define DHT11_PORT  PORTD
#define DHT11_PINR  PIND
#define DHT11_BIT   PD2

//---------------- Pulsador en PD3 ----------------
#define BTN_DDR     DDRD
#define BTN_PORT    PORTD
#define BTN_PINR    PIND
#define BTN_BIT     PD3

//---------------- Funciones DHT11 ----------------
static void DHT11_PinOutput(void)
{
	DHT11_DDR |= (1 << DHT11_BIT);
}

static void DHT11_PinInput(void)
{
	DHT11_DDR &= ~(1 << DHT11_BIT);
}

static uint8_t DHT11_ReadPin(void)
{
	return (DHT11_PINR & (1 << DHT11_BIT)) ? 1 : 0;
}

static uint8_t DHT11_ReadByte(void)
{
	uint8_t i, byte = 0;

	for (i = 0; i < 8; i++)
	{
		while (DHT11_ReadPin() == 0);  // esperar flanco a HIGH
		_delay_us(30);

		byte <<= 1;
		if (DHT11_ReadPin())
		byte |= 1;

		while (DHT11_ReadPin() == 1);  // esperar que vuelva a LOW
	}

	return byte;
}

static void DHT11_Leer(uint8_t *temperatura)
{
	uint8_t datos[5] = {0, 0, 0, 0, 0};
	uint8_t i;

	// Se�al de inicio
	DHT11_PinOutput();
	DHT11_PORT |= (1 << DHT11_BIT);
	_delay_ms(1);

	DHT11_PORT &= ~(1 << DHT11_BIT);
	_delay_ms(20);

	DHT11_PORT |= (1 << DHT11_BIT);
	_delay_us(30);
	DHT11_PinInput();

	// Respuesta del DHT11
	while (DHT11_ReadPin() == 1);
	while (DHT11_ReadPin() == 0);
	while (DHT11_ReadPin() == 1);

	for (i = 0; i < 5; i++)
	datos[i] = DHT11_ReadByte();

	*temperatura = datos[2];   // temperatura entera �C
}

//---------------- PROGRAMA PRINCIPAL ----------------
int main(void)
{
	uint8_t  temperatura     = 0;
	uint8_t  estado_boton    = 0;
	uint16_t valor_pot       = 0;   // 0..1023
	uint8_t  duty_pwm        = 0;   // 0..255
	uint8_t  flag_temp_mayor = 0;
	uint8_t  flag_boton      = 0;

	char linea1[17];
	char linea2[17];

	//---- SPI maestro ----
	SPI_INICIAR();             // configura PB2, PB3, PB5 como salida, MSTR=1, SPE=1
	DDRB  |= (1 << PB2);       // asegurar PB2 (SS) como salida
	PORTB |= (1 << PB2);       // SS en alto (esclavo deseleccionado)

	//---- Pulsador PD3 como entrada con pull-up ----
	BTN_DDR  &= ~(1 << BTN_BIT);
	BTN_PORT |= (1 << BTN_BIT);

	//---- Potenci�metro en A0 (PC0) ----
	DDRC &= ~(1 << PC0);   // entrada anal�gica
	ADC_INICIAR();

	//---- I2C + LCD ----
	I2C_INICIAR();
	LCD_INICIAR();

	while (1)
	{
		//--- Leer temperatura del DHT11 ---
		DHT11_Leer(&temperatura);

		//--- Flag seg�n temperatura ---
		flag_temp_mayor = (temperatura > TEMP_UMBRAL) ? 1 : 0;

		//--- Leer estado del bot�n ---
		// 1 = suelto (pull-up), 0 = presionado (a GND)
		estado_boton = (BTN_PINR & (1 << BTN_BIT)) ? 1 : 0;
		// Flag que se env�a al esclavo: 1 cuando bot�n est� presionado
		flag_boton   = (estado_boton == 0) ? 1 : 0;

		//--- Leer potenci�metro en A0 y escalar a 0..255 ---
		valor_pot = ADC_LEER_CANAL(0);          // 0..1023
		duty_pwm  = (uint8_t)(valor_pot >> 2);  // dividir entre 4 ? 0..255

		//--- Env�o SPI: 3 bytes por r�faga ---
		PORTB &= ~(1 << PB2);              // SS LOW - selecciona esclavo

		SPI_TRANSFERIR(duty_pwm);          // 1) PWM motor
		SPI_TRANSFERIR(flag_temp_mayor);   // 2) temp>umbral
		SPI_TRANSFERIR(flag_boton);        // 3) bot�n

		PORTB |= (1 << PB2);               // SS HIGH - fin de transmisi�n

		//--- Actualizar LCD ---
		snprintf(linea1, sizeof(linea1), "T:%3dC  P:%4u", temperatura, valor_pot);

		if (estado_boton == 0)
		snprintf(linea2, sizeof(linea2), "BTN:ON");
		else
		snprintf(linea2, sizeof(linea2), "BTN:OFF");

		LCD_MOSTRAR(linea1, linea2);

		_delay_ms(1000);
	}

	return 0;
}

