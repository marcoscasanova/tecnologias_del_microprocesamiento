; LABORATORIO_Problema_B.asm
	; Created: 14/9/2025 13:21:45
; Author: Marcos Casanova, Luis Bouvier, Santiago Moizo

.equ F_CPU = 16000000						;Se define el valor de la variable F_CPU (frecuencia del microcontrolador)
.equ baud = 9600						;Se define el valor de la variable baud ()
.equ bps = (F_CPU/16/baud) - 1					;Se define el valor de la variable bps (baudios por segundo) como el resultado de la operación indicada

.cseg								;Inicio del segmento de instrucciones
.org 0x00							;Direccion de inicio
    rjmp INICIO							;Salto relativo a etiqueta INICIO

INICIO:									
;Inicialización del stack pointer
    ldi r16, LOW(RAMEND)
    out SPL, r16
    ldi r16, HIGH(RAMEND)
    out SPH, r16

    clr r1							;Limpia el registro r1 para eliminar y/o evitar residuos temporales

    ldi r16, 0xFC						;Carga inmediatamente el valor hexadecimal FC en el registro r16
    out DDRD, r16						;Asigna como salida los pines PD2, PD3, PD4, PD5, PD6 y PD7.
    clr r16							;Limpia el registro r16 para eliminar y/o evitar residuos temporales
    out PORTD, r16						;Pone en nivel bajo los pines configurados como salida del puerto D
    ldi r16, 0x3F						;Carga inmediatamente el valor hexadecimal 3F en el registro r16
    out DDRB, r16						;Asigna como salida los pines PB0, PB1, PB2, PB3, PB4 y PB5
    ldi r16, 0x3C						;Carga inmediatamente el valor hexadecimal 3C en el registro r16
    out PORTB, r16						;Pone en nivel bajo los pines configurados como salida del puerto B
    ldi r16, 0b0F						;Carga inmediatamente el valor hexadecimal 0F en el registro r16
    out DDRC, r16						;Asigna como salida los pines PC0, PC1, PC2 y PC3
    out PORTC, r16						;Pone en nivel bajo los pines configurados como salida del puerto C

    clr r17							;Limpia el registro r17 para eliminar y/o evitar residuos temporales

    sts pos, r17						;Guarda directamente el valor del registro r17 en pos (variable posición del mensaje)

    ldi r16, LOW(bps)
    sts UBRR0L, r16						;Configura la parte baja del divisor de baudios (UBRR0L en 0xC4)
    ldi r16, HIGH(bps)
    sts UBRR0H, r16						;Configura la parte alta del divisor de baudios (UBRR0H en 0xC5)

    ldi r16, (1<<RXEN0)|(1<<TXEN0)				;Habilita la recepción (RX) y transmisión (TX) de la UART
    sts UCSR0B, r16						;Guarda la configuración en el registro de control UART B
    ldi r16, (1<<UCSZ01)|(1<<UCSZ00)				;Configura el formato de datos de la UART en 8 bits
    sts UCSR0C, r16						;Guarda la configuración en el registro de control UART C

    ldi ZH, HIGH(BIENVENIDA*2)					;Carga en ZH la parte alta de la dirección del mensaje de bienvenida
    ldi ZL, LOW(BIENVENIDA*2)					;Carga en ZL la parte baja de la dirección del mensaje de bienvenida


TX_LOOP:
    lpm r16, Z+							;Carga un byte desde la memoria de programa (tabla apuntada por Z) en r16 y luego incrementa Z
    cpi r16, 0							;Compara r16 con 0 (fin de cadena detectado)
    breq MENU							;Si r16 = 0, salta a MENU; si no, continúa
    rcall UART_TX						;Llama a la rutina de transmisión UART para enviar el byte
    rjmp TX_LOOP						;Repite el bucle de transmisión

MENU:
MAIN_LOOP:
    lds r18, UCSR0A						;Carga directamente el contenido de UCSR0A (registro de estado UART A) en el registro r18
    sbrs r18, RXC0						;Si el bit RXC0 = 0, salta la siguiente instrucción; si = 1, la ejecuta
    rjmp NO_UART						;Si no hay dato recibido, salta a NO_UART
    lds r16, UDR0						;Carga directamente el valor de UDR0 (buffer de recepción UART) en el registro r16
    sts modo, r16						;Guarda directamente el valor del registro r16 en modo

NO_UART:
    lds r16, modo						;Carga directamente el valor de la variable modo en el registro r16
    cpi r16, 'M'						;Compara r16 con el carácter 'M' (Mensaje)
    breq MOSTRAR_MENSAJE					;Si r16 = M, salta a MOSTRAR_MENSAJE; si no, continúa
    cpi r16, '1'						;Compara r16 con el carácter '1' (Cara feliz)
    breq FIGURA1						;Si r16 = 1, salta a FIGURA1; si no, continúa
    cpi r16, '2'						;Compara r16 con el carácter '2' (Cara triste)
    breq FIGURA2						;Si r16 = 2, salta a FIGURA2; si no, continúa
    cpi r16, '3'						;Compara r16 con el carácter '3' (Corazón)
    breq FIGURA3						;Si r16 = 3, salta a FIGURA3; si no, continúa
    cpi r16, '4'						;Compara r16 con el carácter '4' (Rombo)
    breq FIGURA4						;Si r16 = 4, salta a FIGURA4; si no, continúa
    cpi r16, '5'						;Compara r16 con el carácter '5' (Alien)
    breq FIGURA5						;Si r16 = 5, salta a FIGURA5; si no, continúa
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

MOSTRAR_MENSAJE:
    clr r17							;Limpia el registro r17 para inicializar el contador de posición del mensaje
    sts pos, r17						;Guarda directamente el valor del registro r17 en pos (posición del mensaje)

MSG_LOOP:
    ldi r24, 200						;Carga inmediatamente el valor 200 decimal en el registro r24 (bucle de retardo)

MSG_WAIT_LOOP:			
    rcall REFRESCAR						;Hace una llamada relativa a la subrutina REFRESCAR
    dec r24							;Decrementa el valor del registro r24
    brne MSG_WAIT_LOOP						;Salta a MSG_WAIT_LOOP si r24 es distinto de 0
    lds r17, pos						;Carga directamente el valor de pos en el registro r17
    inc r17							;Incrementa el valor del registro r17
    cpi r17, MSG_LEN						;Compara inmediatamente el contenido de la constante MSG_LEN con el valor del registro r17
    brlo NO_FIN							;Si el valor de r17 es menor al de MSG_LEN, salta a la etiqueta NO_FIN, sino, continúa
    rcall APAGAR_DISPLAY					;Se hace una llamada relativa a la subrutina APAGAR_DISPLAY
    sts pos, r17						;Se carga directamente el valor del registro r17 en la variable pos (posición del mensaje)
    clr r16							;Limpia el registro r16 para reiniciar el modo
    sts modo, r16						;Se carga directamente el valor del registro r16 en la variable modo
    rjmp MENU							;Salto relativo a la etiqueta MENU

NO_FIN:
    sts pos, r17						;Guarda directamente el valor del registro r17 en la variable pos (posición del mensaje)
    rjmp MSG_LOOP						;Salto relativo a la etiqueta MSG_LOOP

FIGURA1:
    ldi ZH, HIGH(CARA_FELIZ*2)					;Carga inmediatamente la parte alta de la dirección de la figura CARA_FELIZ en ZH
    ldi ZL, LOW(CARA_FELIZ*2)					;Carga inmediatamente la parte baja de la dirección de la figura CARA_FELIZ en ZL
    rcall MULTIPLEX_DISPLAY					;Hace una llamada relativa a la subrutina MULTIPLEX_DISPLAY
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

FIGURA2:
    ldi ZH, HIGH(CARA_TRISTE*2)					;Carga inmediatamente la parte alta de la dirección de la figura CARA_TRISTE en ZH
    ldi ZL, LOW(CARA_TRISTE*2)					;Carga inmediatamente la parte baja de la dirección de la figura CARA_TRISTE en ZL
    rcall MULTIPLEX_DISPLAY					;Hace una llamada relativa a la subrutina MULTIPLEX_DISPLAY
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

FIGURA3:
    ldi ZH, HIGH(CORAZON*2)					;Carga inmediatamente la parte alta de la dirección de la figura CORAZON en ZH
    ldi ZL, LOW(CORAZON*2)					;Carga inmediatamente la parte baja de la dirección de la figura CORAZON en ZL
    rcall MULTIPLEX_DISPLAY					;Hace una llamada relativa a la subrutina MULTIPLEX_DISPLAY
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

FIGURA4:
    ldi ZH, HIGH(ROMBO*2)					;Carga inmediatamente la parte alta de la dirección de la figura ROMBO en ZH
    ldi ZL, LOW(ROMBO*2)					;Carga inmediatamente la parte baja de la dirección de la figura ROMBO en ZL
    rcall MULTIPLEX_DISPLAY					;Hace una llamada relativa a la subrutina MULTIPLEX_DISPLAY
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

FIGURA5:
    ldi ZH, HIGH(ALIEN*2)					;Carga inmediatamente la parte alta de la dirección de la figura ALIEN en ZH
    ldi ZL, LOW(ALIEN*2)					;Carga inmediatamente la parte baja de la dirección de la figura ALIEN en ZL
    rcall MULTIPLEX_DISPLAY					;Hace una llamada relativa a la subrutina MULTIPLEX_DISPLAY
    rjmp MAIN_LOOP						;Salto relativo a la etiqueta MAIN_LOOP

UART_TX:
    lds r18, UCSR0A						;Carga directamente el valor del registro UCSR0A en el registro r18
    sbrs r18, UDRE0						;Omite la siguiente instrucción si el bit UDRE0 está en 0 (buffer de transmisión no listo)
    rjmp UART_TX						;Salto relativo a la etiqueta UART_TX (espera hasta que el buffer de transmisión esté listo)
    sts UDR0, r16						;Guarda directamente el valor del registro r16 en UDR0 (envía el dato por UART)
    ret								;Retorno de la subrutina

REFRESCAR:
    push r16							;Guarda en la pila el valor actual del registro r16
    push r17							;Guarda en la pila el valor actual del registro r17
    push r18							;Guarda en la pila el valor actual del registro r18
    push r19							;Guarda en la pila el valor actual del registro r19
    push r20							;Guarda en la pila el valor actual del registro r20
    lds r17, pos						;Carga directamente el valor de la variable pos en el registro r17
    ldi ZH, HIGH(MENSAJE*2)					;Carga inmediatamente la parte alta de la dirección de MENSAJE en ZH
    ldi ZL, LOW(MENSAJE*2)					;Carga inmediatamente la parte baja de la dirección de MENSAJE en ZL
    add ZL, r17							;Suma el valor de r17 al registro ZL
    adc ZH, r1							;Suma con acarreo el valor del registro r1 al registro ZH
    ldi r20, 0							;Carga inmediatamente el valor 0 en r20 (contador de columnas)
    rjmp REFRESH_COL_LOOP					;Salto relativo a la etiqueta REFRESH_COL_LOOP

MULTIPLEX_DISPLAY:
    push r16							;Guarda en la pila el valor actual del registro r16
    push r17							;Guarda en la pila el valor actual del registro r17
    push r18							;Guarda en la pila el valor actual del registro r18
    push r19							;Guarda en la pila el valor actual del registro r19
    push r20							;Guarda en la pila el valor actual del registro r20
    ldi r20, 0							;Carga inmediatamente el valor 0 en r20 (contador de columnas)

REFRESH_COL_LOOP:
    lpm r19, Z+							;Carga un byte desde la memoria de programa (puntero Z) en r19 e incrementa Z
    in r18, PORTD						;Carga directamente el valor actual de PORTD en r18
    andi r18, 0b00000011					;Mantiene únicamente los 2 bits menos significativos de r18
    out PORTD, r18						;Guarda directamente el valor de r18 en PORTD
    in r18, PORTB						;Carga directamente el valor actual de PORTB en r18
    andi r18, 0b11111100					;Mantiene únicamente los 2 bits menos significativos de r18
    out PORTB, r18						;Guarda directamente el valor de r18 en PORTB
    mov r16, r19						;Copia el valor del registro r19 en el registro r16
    andi r16, 0x0F						;Enmascara los 4 bits menos significativos de r16
    com r16							;Complementa lógicamente todos los bits del registro r16
    andi r16, 0x0F						;Mantiene únicamente los 4 bits menos significativos de r16
    lsl r16							;Desplaza una posición a la izquierda el valor de r16
    lsl r16							;Desplaza una posición a la izquierda el valor de r16
    in r18, PORTB						;Carga directamente el valor actual de PORTB en r18
    andi r18, 0b11000011					;Mantiene únicamente los bits PB7, PB6, PB1 y PB0 de r18
    or r18, r16							;Combina el contenido del registro r16 con el de r18
    out PORTB, r18						;Guarda directamente el valor de r18 en PORTB
    mov r16, r19						;Copia el valor del registro r19 en el registro r16
    swap r16							;Intercambia los nibbles alto y bajo del registro r16
    andi r16, 0x0F						;Enmascara los 4 bits menos significativos de r16
    com r16							;Complementa lógicamente todos los bits del registro r16
    andi r16, 0x0F						;Mantiene únicamente los 4 bits menos significativos de r16
    in r18, PORTC						;Carga directamente el valor actual de PORTC en r18
    andi r18, 0b11110000					;Mantiene únicamente los 4 bits más significativos de r18
    or r18, r16							;Combina el contenido del registro r16 con el de r18
    out PORTC, r18						;Guarda directamente el valor de r18 en PORTC
    rcall SELECT_COLUMN						;Hace una llamada relativa a la subrutina SELECT_COLUMN
    ldi r16, 200						;Carga inmediatamente el valor 200 en r16 (contador de retardo)

RC_DELAY:
    dec r16							;Decrementa el valor del registro r16
    brne RC_DELAY						;Salta a RC_DELAY si r16 es distinto de 0
    inc r20							;Incrementa el valor del registro r20 (contador de columnas)
    cpi r20, 8							;Compara inmediatamente el valor de r20 con 8
    brlo REFRESH_COL_LOOP					;Si el valor de r20 es menor que 8, salta a REFRESH_COL_LOOP
    pop r20							;Restaura el valor original del registro r20 desde la pila
    pop r19							;Restaura el valor original del registro r19 desde la pila
    pop r18							;Restaura el valor original del registro r18 desde la pila
    pop r17							;Restaura el valor original del registro r17 desde la pila
    pop r16							;Restaura el valor original del registro r16 desde la pila
    ret								;Retorno de la subrutina

SELECT_COLUMN:
    cpi r20, 0							;Compara inmediatamente el valor de r20 con 0
    breq SC0							;Si r20 = 0, salta a SC0
    cpi r20, 1							;Compara inmediatamente el valor de r20 con 1
    breq SC1							;Si r20 = 1, salta a SC1
    cpi r20, 2							;Compara inmediatamente el valor de r20 con 2
    breq SC2							;Si r20 = 2, salta a SC2
    cpi r20, 3							;Compara inmediatamente el valor de r20 con 3
    breq SC3							;Si r20 = 3, salta a SC3
    cpi r20, 4							;Compara inmediatamente el valor de r20 con 4
    breq SC4							;Si r20 = 4, salta a SC4
    cpi r20, 5							;Compara inmediatamente el valor de r20 con 5
    breq SC5							;Si r20 = 5, salta a SC5
    cpi r20, 6							;Compara inmediatamente el valor de r20 con 6
    breq SC6							;Si r20 = 6, salta a SC6
    sbi PORTB, PB1						;Setea en alto el pin PB1 (columna 7)
    ret								;Retorno de la subrutina

SC0: sbi PORTD, PD2						;Setea en alto el pin PD2 (columna 0)
    ret								;Retorno de la subrutina

SC1: sbi PORTD, PD3						;Setea en alto el pin PD3 (columna 1)
    ret								;Retorno de la subrutina

SC2: sbi PORTD, PD4						;Setea en alto el pin PD4 (columna 2)
    ret								;Retorno de la subrutina

SC3: sbi PORTD, PD5						;Setea en alto el pin PD5 (columna 3)
    ret								;Retorno de la subrutina

SC4: sbi PORTD, PD6						;Setea en alto el pin PD6 (columna 4)
    ret								;Retorno de la subrutina

SC5: sbi PORTD, PD7						;Setea en alto el pin PD7 (columna 5)
    ret								;Retorno de la subrutina

SC6: sbi PORTB, PB0						;Setea en alto el pin PB0 (columna 6)
    ret								;Retorno de la subrutina

APAGAR_DISPLAY:
    in r16, PORTD						;Carga directamente el valor actual de PORTD en r16
    andi r16, 0b00000011					;Mantiene únicamente los 2 bits menos significativos de r16
    out PORTD, r16						;Guarda directamente el valor de r16 en PORTD
    in r16, PORTB						;Carga directamente el valor actual de PORTB en r16
    andi r16, 0b11111100					;Mantiene únicamente los 2 bits menos significativos de r16
    out PORTB, r16						;Guarda directamente el valor de r16 en PORTB
    in r16, PORTB						;Carga directamente el valor actual de PORTB en r16
    ori r16, 0b00111100						;Setea en alto los bits PB2..PB5
    out PORTB, r16						;Guarda directamente el valor de r16 en PORTB
    in r16, PORTC						;Carga directamente el valor actual de PORTC en r16
    ori r16, 0b00001111						;Setea en alto los bits PC0..PC3
    out PORTC, r16						;Guarda directamente el valor de r16 en PORTC
    ret								;Retorno de la subrutina

.dseg								;Inicio del segmento de datos en RAM

pos: .byte 1							;Reserva 1 byte en memoria de datos para la variable pos (posición del mensaje)
modo: .byte 1							;Reserva 1 byte en memoria de datos para la variable modo (modo de funcionamiento)

.cseg								;Inicio del segmento de instrucciones

MENSAJE:
.db 0b11111111,0b11111111,0b00000110,0b00001100,0b00001100,0b00000110,0b11111111,0b11111111	;M
.db 0x00							;Espacio para diferenciar entre caractéres																	
.db 0b00000000,0b00000000,0b00000000,0b11111011,0b11111011,0b00000000,0b00000000,0b00000000	;I
.db 0x00							;Espacio para diferenciar entre caractéres																						
.db 0b00111100,0b01111110,0b11100111,0b11000011,0b11000011,0b11000011,0b11000011,0b11000011	;C
.db 0x00							;Espacio para diferenciar entre caractéres												
.db 0b11111111,0b11111111,0b00110011,0b00110011,0b00110011,0b01110011,0b11011110,0b10001100	;R
.db 0x00							;Espacio para diferenciar entre caractéres																						
.db 0b00111100,0b01111100,0b11000011,0b11000011,0b11000011,0b11000011,0b01111110,0b00111100	;O
.db 0x00							;Espacio para diferenciar entre caractéres																							
.db 0b11111111,0b11111111,0b00110011,0b00110011,0b00110011,0b00110011,0b00011110,0b00001100	;P
.db 0x00							;Espacio para diferenciar entre caractéres																						
.db 0b11111111,0b11111111,0b00110011,0b00110011,0b00110011,0b01110011,0b11011110,0b10001100	;R
.db 0x00							;Espacio para diferenciar entre caractéres																							
.db 0b00111100,0b01111100,0b11000011,0b11000011,0b11000011,0b11000011,0b01111110,0b00111100	;O
.db 0x00							;Espacio para diferenciar entre caractéres																							
.db 0b00111100,0b01111110,0b11100111,0b11000011,0b11000011,0b11000011,0b11000011,0b11000011	;C
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b11111111,0b11111111,0b11011011,0b11011011,0b11011011,0b11011011,0b11011011,0b11011011	;E
.db 0x00							;Espacio para diferenciar entre caractéres																							
.db 0b11011111,0b11011111,0b11011011,0b11011011,0b11011011,0b11011011,0b11111011,0b11111011	;S
.db 0x00							;Espacio para diferenciar entre caractéres																						
.db 0b11111100,0b11111110,0b00110011,0b00110011,0b00110011,0b00110011,0b11111110,0b11111100	;A
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b11111111,0b11111111,0b00000110,0b00001100,0b00001100,0b00000110,0b11111111,0b11111111	;M
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b00000000,0b00000000,0b00000000,0b11111011,0b11111011,0b00000000,0b00000000,0b00000000	;I
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b11111111,0b11111111,0b11011011,0b11011011,0b11011011,0b11011011,0b11011011,0b11011011	;E
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b11111111,0b11111111,0b00001110,0b00011100,0b00111000,0b01110000,0b11111111,0b11111111	;N
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b00000011,0b00000011,0b00000011,0b11111111,0b11111111,0b00000011,0b00000011,0b00000011	;T
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b00111100,0b01111100,0b11000011,0b11000011,0b11000011,0b11000011,0b01111110,0b00111100	;O
.db 0x00							;Espacio para diferenciar entre caractéres																					
.db 0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000	;Espacio
.db 0x00							;Espacio para diferenciar entre caractéres																						

.equ MSG_LEN = 171						;Longitud total del mensaje en bytes (carácteres * 9 (8 columnas + espacio))

CARA_FELIZ:
.db 0b00000000,0b00110000,0b01000110,0b01000000,0b01000000,0b01000110,0b00110000,0b00000000

CARA_TRISTE:
.db 0b00000000,0b01100000,0b00010110,0b00010000,0b00010000,0b00010110,0b01100000,0b00000000

CORAZON:
.db 0b00000000,0b00001100,0b00010010,0b00100100,0b00010010,0b00001100,0b00000000,0b00000000

ROMBO:
.db 0b00001000,0b00010100,0b00100010,0b01000001,0b00100010,0b00010100,0b00001000,0b00000000

ALIEN:
.db 0b00110000,0b00011000,0b01110101,0b00111110,0b00111110,0b01110101,0b00011000,0b00110000

BIENVENIDA:
.db "Seleccione una opcion: M=Mensaje, 1=Cara feliz, 2=Cara triste, 3=Corazon, 4=Rombo, 5=Alien",0
